# 一、写数据
	I2C_WriteBuffer(buffer,Addr,Datas,Len)
	buffer	缓冲区结构体指针
	Addr	器件地址
	Datas	数据数组
	Len 	数据长度
## 1、器件地址是否合并到数据数组
	从固件库的设定而言不合并
	后期可能有断点续传需要地址信息不合并
	失败重传可以合并
## 2、寄存器地址是否从数据数组分离
	大部分I2C器件使用寄存器方式不知是否有特例
	断点续传需要不合并
	失败重传可以合并
## 3、数据数组是否拷贝到缓冲区
	拷贝到缓冲区可以避免用户修改数组或临时数组问题
	多个传输进程需要考虑缓冲区如何排序：安排出Len长度的空间
## 4、方案
###	A：一维环形缓冲区，起始指令+长度+(数据-1)+停止指令，器件地址合并至数组，寄存器地址合并至数组，数据拷贝缓冲区。
		如向0xD0的0x05~0x08寄存器发送0x50 0x51 0x52 0x53的缓冲区指令为：
		00 05 D0 05 50 51 52 53 01
		其中：00=起始信号；05=数据长度-1；D0=地址；05=寄存器；50 51 52 53 数据；01=停止信号
###	B：一维环形缓冲区，指令+地址+寄存器+(长度-1)+数据+停止指令，器件地址不合并至数组，寄存器地址不合并至数组，数据拷贝缓冲区。
		如向0xD0的0x05~0x08寄存器发送0x50 0x51 0x52 0x53的缓冲区指令为：
		00 D0 05 03 50 51 52 53 01
		其中：00=起始信号；D0=地址；05=寄存器；03=数据长度-1；50 51 52 53 数据；01=停止信号
###	C：结构体+数据双环形缓冲区，器件地址、寄存器地址不合并至数组，数据拷贝缓冲区。
		结构体：Addr器件地址，Reg寄存器，Datas数据起始索引，Len数据长度-1
		如向0xD0的0x05~0x08寄存器发送0x50 0x51 0x52 0x53：
		结构体{0xD0,0x05,0,3}
		缓冲区0x50 0x51 0x52 0x53
		其中，结构体中的0为假设缓冲区全空时提供的索引
###	D：结构体+数据双环形缓冲区，器件地址、寄存器地址合并至数组，数据拷贝缓冲区。
		结构体：Datas数据起始索引，Len数据长度-1
		如向0xD0的0x05~0x08寄存器发送0x50 0x51 0x52 0x53：
		结构体{0,5}
		缓冲区0xD0 0x05 0x50 0x51 0x52 0x53
		其中，结构体中的0为假设缓冲区全空时提供的索引
# 二、读数据
	I2C_ReadBuffer(buffer,Addr,Datas,Len)
	buffer	缓冲区结构体指针
	Addr	器件地址
	Datas	数据数组
	Len 	数据长度
## 1、器件地址是否合并到数据数组
	读数据流程为：起始 地址0 寄存器 重起始 地址1 数据... 停止
	其中收发关系：-    w    w      -     w     r  ...  -
	如果考虑使用重复起始信号，则前后读写应连续。
## 2、寄存器是否合并到数据数组
	同上
## 3、数据数组是否使用缓冲区
	使用缓冲区，数据数组使用数组指针的指针形式，函数反设置用户数组指针。
	不使用缓冲区，数据数组传入用户数组指针。
	使用回调函数+缓冲区，强制处理完接收数据才能继续传输。
	如何确定用户已经读出缓冲区数据(都无法实现，发现逻辑错误，忽略后面内容)？一维环形缓冲区目前无法实现，不管此问题；结构体+数据可修改十六位数据起始索引最高位为1代表用户未读出数据或在结构体内加入flag,假设传输完成后设置标志，用户读取清除标志，当用户未读取但前指针重新到达此位置时跳过此位置，后指针到达时清除标志并跳过此位置，防止用户迟迟不读取数据或默认数据为置位状态导致缓冲区不可逆减小。
## 4、方案
###	A：一维环形缓冲区，起始指令+(长度-1)+数据+停止指令，器件地址、寄存器地址合并至数组，数据使用缓冲区。
		如从0xD0的0x05~0x08寄存器读取4个数据的缓冲区指令：
		00 01 D0 05 00 04 D1 XX XX XX XX 01
		其中：00=起始信号；01=长度-1；D0=地址写；05=寄存器；00=重起始信号；04=长度-1；D1=地址读；XX XX XX XX 保留数据位置；01=停止信号
###	B：一维环形缓冲区，指令+地址+寄存器+(长度-1)+数据+停止指令，器件地址、寄存器地址不合并至数组，数据使用缓冲区。
		如从0xD0的0x05~0x08寄存器读取4个数据的缓冲区指令：
		00 D1 05 03 XX XX XX XX 01
		其中：00=起始信号；D1=地址+读；05=寄存器；03=数据长度-1；XX XX XX XX 保留数据位置；01=停止信号（可不用）
###	C：一维环形缓冲区，指令+地址+长度+数据+停止指令，器件地址不合并至数组，寄存器地址合并至数组，数据使用缓冲区。
		如从0xD0的0x05~0x08寄存器读取4个数据的缓冲区指令：
		00 D0 00 05 00 D1 03 XX XX XX XX 01
		其中：00=起始信号；D0=地址写；00=数据长度-1；05=数据（寄存器）；
		00=重复起始；D1=地址读；03=数据长度-1；XX XX XX XX 保留数据位置；01=停止信号
###	D：结构体+数据双环形缓冲区，器件地址、寄存器地址不合并至数组，数据拷贝缓冲区。
		结构体：Addr器件地址，Reg寄存器，Datas数据起始索引，Len数据长度-1
		如从0xD0的0x05~0x08寄存器读取4个数据：
		结构体{0xD1,0x05,0,3}
		缓冲区XX XX XX XX
		其中，结构体中的0为假设缓冲区全空时提供的索引
###	E：结构体+数据双环形缓冲区，器件地址、寄存器地址合并至数组，数据拷贝缓冲区。
		结构体：Datas数据起始索引，Len数据长度-1
		如从0xD0的0x05~0x08寄存器读取4个数据：
		结构体{0,1}{2,4}
		缓冲区D0 05 D1 XX XX XX XX
		其中，结构体中的首个0为假设缓冲区全空时提供的索引
###	F：结构体+数据双环形缓冲区，器件地址不合并至数组,寄存器地址合并至数组，数据拷贝缓冲区。
		结构体：Addr器件地址，Datas数据起始索引，Len数据长度-1
		如从0xD0的0x05~0x08寄存器读取4个数据：
		结构体{0xD0,0,0}{0xD1,1,3}
		缓冲区05 XX XX XX XX
		其中，结构体中的首个0为假设缓冲区全空时提供的索引
## 5、分析
对应接收部分6个方案进行分析：
方案|最小占用|最大连续数据(1)|重复起始|拓展性
-|-|-|-|-
A|9B|254B|手动|中
B|5B|256B|自动|低
C|9B|256B|手动|高
D|9B|256B|自动|低
E|10B|256B|判断|中
F|10B|256B|判断|高
---
(1)既不包括地址及寄存器

# 三、程序
	暂时选用D方案实现缓冲区读写。
	结构体+数据双环形缓冲区，器件地址、寄存器地址不合并至数组，数据拷贝缓冲区。
	结构体：Addr器件地址，Reg寄存器，Datas数据起始索引，Len数据长度-1

## 1、结构体

```
//索引结构体
typedef struct
{
	//器件地址+读/写
	uint8_t Addr;
	//寄存器地址
	uint8_t Reg;
	//数据起始指针
	uint8_t *Index;
	//数据长度-1
	uint8_t Len;
} I2C_IdxBuffer;
//缓冲区结构体
typedef struct
{
	//缓冲区所用的I2C
	I2C_TypeDef *I2Cx;
	//索引缓冲区
	I2C_IdxBuffer *IdxBuffer;
	//索引缓冲区大小
	uint16_t IdxSize;
	//索引缓冲区队头指针
	I2C_IdxBuffer *pIHead;
	//索引缓冲区队尾指针
	I2C_IdxBuffer *pITail;
	//索引缓冲区空标志位
	uint8_t IdxEmpty;
	//数据缓冲区
	uint8_t *DataBuffer;
	//数据缓冲区大小
	uint16_t DataSize;
	//数据缓冲区队头索引
	uint16_t iDHead;
	//数据缓冲区队尾索引
	uint16_t iDTail;
	//数据缓冲区空标志位
	uint8_t DataEmpty;
} I2C_Buffer;
```

## 2、缓冲区算法

	W_fcn()
	{
		判断缓冲区是否已满
		判断缓冲区剩余空间是否足够
		//向前检查索引结构体缓冲区的有用户未读取标志位
		填充数据缓冲区
		填充结构体缓冲区
		修改索引头
		修改索引头

		启动流程(START)
	}

	[1/5]
	0 0 1 0 0
	      ^3
	    |2
	+2
	0 0 1 1 1
	^0
	    |2
	+5X
	1 1 2 1 1
	      ^3
	    |2
	[1/5]
	0 0 0 0 1
	^0
	        |4
	+5X
	1 1 1 1 2
	^0
	        |4
	[3/5]
	1 1 0 0 1
	    ^2
	        |4
	+3X
	0 0 1 1 2
	^0
		    |4

## 3、读取算法

	R_Fcn()
	{
		判断缓冲区是否已满
		填充结构体缓冲区
		修改索引头

		启动流程(START)
	}

## 4、中断程序

### 自启动

	Restart()
	{
		BUSY且SDA低电平，重启计数//中断清空计数
		判断重启计数，重启I2C
		判断缓冲区非空
		检查BUSY||START||STOP
		开启I2C_CR2_ITBUFEN | I2C_CR2_ITEVTEN | I2C_CR2_ITERREN
		发送START
	}

### 中断标志位

EV

	SB,
	ADDR,ADDR10,
	STOPF,BTF,
	TXE & ITBUFEN
	RXNE & ITBUFEN

ER

名称|描述|条件|清除|自动
-|-|-|-|-
BERR|总线出错|检测到错误的起始或停止条件|软件写’0’|无
ARLO|仲裁丢失|检测到仲裁丢失|软件写’0’|切换回从模式
AF|应答失败|应答失败|软件写’0’|无
OVR|过载/欠载|从模式过载/欠载|软件写’0’|无
PECERR|接收PEC错误||软件写’0’|无
TIMEOUT|超时|SCL处于低已达到25ms|软件写’0’|发出停止条件
SMBAlort|SMBus提醒||软件写’0’|

### 中断流程

发送

- SB : 起始信号发送完成，发送写地址,开启ITBUFEN
- ADDR TX : 地址发送完成，发送寄存器
- TXE : 数据寄存器空，写入数据
- TXE(1) : 数据寄存器空，写入最后一个数据,关闭ITBUFEN
- BTF : 数据写完，发送重新起始(停止条件)，切换索引结构体

接收

- SB : 起始信号发送完成，发送写地址，开启ITBUFEN
- ADDR TX : 地址发送完成，发送寄存器,关闭ITBUFEN
- BTF : 寄存器发送完毕，重复起始
- SB : 起始信号发送完成，发送读地址，开启ITBUFEN
- ADDR RX : 地址发送完成，准备接收
- ADDR RX(1) : 直接收一个字节，设置ACK=0及STOP
- RXNE : 接收到数据
- RXNE(1) : 接收到数据,准备接收最后一个字节，设置ACK=0及RESTART(STOP)
- RXNE(2) : 接收完最后一个字节，切换索引结构体

中断将清空I2C死机自动重启的计数

注：发送BTF及接收RXNE(1)中，当缓冲区有后续数据时，发送重新起始，当缓冲区没有后续数据时，发送停止条件结束中断循环。